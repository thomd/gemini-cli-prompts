description = "Design a system architecture."
prompt = """
# System Architecture Design

Please design a comprehensive system architecture for the following requirements:

{{args}}

## System Design Framework

### 1. Requirements Clarification

#### Functional Requirements
- What features/capabilities are needed?
- What are the core use cases?
- What are the user workflows?

#### Non-Functional Requirements
- Performance: Response time, throughput targets
- Scalability: Expected user/data growth
- Availability: Uptime requirements (99.9%, 99.99%)
- Reliability: Data durability, fault tolerance
- Consistency: Strong vs eventual consistency
- Security: Authentication, encryption, compliance
- Maintainability: Code quality, deployment ease

#### Constraints
- Budget limitations
- Technology restrictions
- Timeline constraints
- Team expertise

### 2. Capacity Estimation

#### Traffic Estimates
```
Daily Active Users (DAU): 1M
Requests per user per day: 50
Total daily requests: 50M
Requests per second (RPS): 50M / 86400 ≈ 580 RPS
Peak RPS (3x average): ~1740 RPS
```

#### Storage Estimates
```
Average data per user: 1KB
Total users: 10M
Total storage: 10GB
Storage growth: 1GB/month
5-year projection: 10GB + (60 months × 1GB) = 70GB
```

#### Bandwidth Estimates
```
Average request size: 1KB
Average response size: 5KB
Total bandwidth: (580 RPS × 6KB) = 3.5 MB/s
```

#### Memory/Cache Estimates
```
Cache 20% of hot data: 2GB
Session storage: 100MB per 10K concurrent users
```

### 3. High-Level Architecture

#### Architecture Diagram (Text Format)
```
                    ┌──────────────┐
                    │    Client    │
                    │  (Web/Mobile)│
                    └──────┬───────┘
                           │
                    ┌──────▼───────┐
                    │     CDN      │
                    └──────┬───────┘
                           │
                    ┌──────▼───────┐
                    │ Load Balancer│
                    └──────┬───────┘
                           │
            ┌──────────────┼──────────────┐
            │              │              │
      ┌─────▼─────┐  ┌─────▼─────┐  ┌─────▼─────┐
      │  Web      │  │  Web      │  │  Web      │
      │  Server 1 │  │  Server 2 │  │  Server 3 │
      └─────┬─────┘  └─────┬─────┘  └─────┬─────┘
            │              │              │
            └──────────────┼──────────────┘
                           │
            ┌──────────────┼──────────────┐
            │              │              │
      ┌─────▼─────┐  ┌─────▼─────┐  ┌─────▼─────┐
      │   Cache   │  │ Message   │  │  Search   │
      │  (Redis)  │  │   Queue   │  │(Elastic)  │
      └───────────┘  └─────┬─────┘  └───────────┘
                           │
            ┌──────────────┼──────────────┐
            │              │              │
      ┌─────▼─────┐  ┌─────▼─────┐  ┌─────▼─────┐
      │  Primary  │  │  Read     │  │  Object   │
      │  Database │  │  Replica  │  │  Storage  │
      └───────────┘  └───────────┘  └───────────┘
```

### 4. Component Design

#### Load Balancer
- Purpose: Distribute traffic across servers
- Options: AWS ALB, Nginx, HAProxy
- Strategies: Round-robin, least connections, IP hash
- Health checks: Regular server health monitoring

#### Web/Application Servers
- Stateless design: No session data on servers
- Horizontal scaling: Add more servers as needed
- Auto-scaling: Scale based on CPU/memory metrics

#### Caching Layer
- Technology: Redis, Memcached
- What to cache:
  - Frequently accessed data
  - Expensive computations
  - Session data
  - API responses
- Cache strategies:
  - Cache-aside (lazy loading)
  - Write-through
  - Write-behind
- TTL: Appropriate expiration times
- Cache invalidation: Clear when data changes

#### Database
- Primary-Replica setup:
  - Write to primary
  - Read from replicas
- Partitioning/Sharding:
  - Horizontal: Split by user_id range
  - Vertical: Split by table/feature
- Indexing: For query optimization
- Connection pooling: Reuse connections

#### Message Queue
- Technology: RabbitMQ, Kafka, AWS SQS
- Use cases:
  - Async processing
  - Event-driven architecture
  - Decoupling services
- Patterns:
  - Producer-Consumer
  - Pub-Sub
  - Request-Reply

#### Object Storage
- Technology: AWS S3, Google Cloud Storage
- Use cases:
  - Images, videos, files
  - Backups
  - Logs
- CDN integration: Fast global access

### 5. Data Flow

#### Read Flow
```
1. Client → CDN (if static content)
2. Client → Load Balancer
3. Load Balancer → Web Server
4. Web Server → Check Cache
   ├─ Cache Hit → Return data
   └─ Cache Miss → Query Database
       └─ Store in Cache → Return data
```

#### Write Flow
```
1. Client → Load Balancer
2. Load Balancer → Web Server
3. Web Server → Validate data
4. Web Server → Write to Primary DB
5. Web Server → Invalidate cache
6. Web Server → Publish event to queue
7. Background worker → Process event
8. Return response to client
```

### 6. Scalability Strategies

#### Horizontal Scaling
- Add more servers/instances
- Load balancer distributes traffic
- Stateless application design required

#### Vertical Scaling
- Increase server resources (CPU, RAM)
- Limited by hardware constraints
- Temporary solution

#### Database Scaling
- Read scaling: Add read replicas
- Write scaling: Sharding/partitioning
- Caching: Reduce DB load
- NoSQL: For specific use cases

#### Microservices
Split monolith into services:
- User Service
- Auth Service
- Product Service
- Order Service
- Payment Service

Each service:
- Independent deployment
- Own database
- Specific responsibility

### 7. Availability & Reliability

#### Redundancy
- Multiple servers in load balancer
- Database replicas
- Multi-region deployment
- Backup systems

#### Fault Tolerance
- Graceful degradation
- Circuit breakers
- Retry logic with exponential backoff
- Timeout configuration

#### Disaster Recovery
- Regular backups
- Backup in different region
- Recovery Time Objective (RTO)
- Recovery Point Objective (RPO)

#### Monitoring
- Metrics: CPU, memory, response time, error rate
- Logging: Centralized logging (ELK stack)
- Alerting: PagerDuty, email, Slack
- Dashboards: Grafana, Datadog

### 8. Security Architecture

#### Network Security
- VPC/Private subnets
- Security groups/Firewall rules
- DDoS protection (Cloudflare, AWS Shield)

#### Application Security
- HTTPS/TLS encryption
- Authentication (JWT, OAuth)
- Authorization (RBAC, ABAC)
- Input validation
- SQL injection prevention
- XSS prevention
- CSRF protection

#### Data Security
- Encryption at rest
- Encryption in transit
- Key management (AWS KMS)
- PII data handling
- Audit logging

### 9. API Gateway Pattern

```
Client → API Gateway → Microservices
```

API Gateway responsibilities:
- Request routing
- Authentication/Authorization
- Rate limiting
- Request/response transformation
- Caching
- Monitoring & logging

### 10. Caching Strategies

#### CDN Caching
- Static assets (JS, CSS, images)
- Geo-distributed
- Edge caching

#### Application Caching
- Redis/Memcached
- Session data
- API responses
- Database query results

#### Browser Caching
- Cache-Control headers
- ETags
- Service Workers

### 11. Async Processing Pattern

```
Web Server → Message Queue → Worker
```

Use cases:
- Email sending
- Image processing
- Report generation
- Data analytics
- Video encoding

### 12. Data Consistency

#### Strong Consistency
- ACID transactions
- Immediate consistency
- Use for: Financial transactions, inventory

#### Eventual Consistency
- BASE properties
- Higher availability
- Use for: Social media feeds, analytics

#### Patterns
- Two-Phase Commit
- Saga Pattern
- Event Sourcing
- CQRS (Command Query Responsibility Segregation)

### 13. Rate Limiting

#### Strategies
- Fixed window
- Sliding window
- Token bucket
- Leaky bucket

#### Implementation
```
Rate Limit: 100 requests per minute per user
Headers:
  X-RateLimit-Limit: 100
  X-RateLimit-Remaining: 95
  X-RateLimit-Reset: 1640000000
```

### 14. Technology Stack Recommendations

Based on requirements, suggest:

#### Frontend
- Framework: React, Vue, Angular
- Mobile: React Native, Flutter
- State Management: Redux, MobX

#### Backend
- Language: Node.js, Python, Java, Go
- Framework: Express, Django, Spring Boot
- API: REST, GraphQL, gRPC

#### Database
- Relational: PostgreSQL, MySQL
- NoSQL: MongoDB, DynamoDB
- Cache: Redis, Memcached
- Search: Elasticsearch

#### Infrastructure
- Cloud: AWS, GCP, Azure
- Containers: Docker, Kubernetes
- CI/CD: GitHub Actions, Jenkins

### 15. Output Format

Provide:

1. Architecture Overview - High-level description
2. Architecture Diagram - Component relationships
3. Component Specifications - Detailed component design
4. Data Flow - Request/response flows
5. Scaling Strategy - How to handle growth
6. Fault Tolerance - Redundancy and recovery
7. Security Measures - Security architecture
8. Technology Stack - Recommended technologies
9. Capacity Planning - Traffic/storage estimates
10. Trade-offs - Design decisions and rationale
11. Deployment Strategy - How to deploy and maintain

Generate a complete, production-ready system architecture following best practices.
"""
